import * as LDtk from "./typedef";
export { LDtk };
/**
 * Represents a point in 2D space (X, Y)
 */
export interface Point {
    x: number;
    y: number;
}
/**
 * Represents a 2D size (width, height)
 */
export interface Size {
    width: number;
    height: number;
}
export declare const enum FieldType {
    /**
     * Value type: `number | null`
     *
     * Associated interface: {@link IntField}
     */
    Int = "Int",
    /**
     * Value type: `number[]`
     *
     * Associated interface: {@link IntArrayField}
     */
    IntArray = "IntArray",
    /**
     * Value type: `number | null`
     *
     * Associated interface: {@link Float}
     */
    Float = "Float",
    /**
     * Value type: `number[]`
     *
     * Associated interface: {@link FloatArrayField}
     */
    FloatArray = "FloatArray",
    /**
     * Value type: `string`
     *
     * Associated interface: {@link StringField}
     */
    String = "String",
    /**
     * Value type: `string[]`
     *
     * Associated interface: {@link StringArrayField}
     */
    StringArray = "StringArray",
    /**
     * Value type: `number`
     *
     * Associated interface: {@link BoolField}
     */
    Bool = "Bool",
    /**
     * Value type: `number[]`
     *
     * Associated interface: {@link BoolArrayField}
     */
    BoolArray = "BoolArray",
    /**
     * Value type: `string`
     *
     * Associated interface: {@link ColorField}
     */
    Color = "Color",
    /**
     * Value type: `string[]`
     *
     * Associated interface: {@link ColorArrayField}
     */
    ColorArray = "ColorArray",
    /**
     * Value type: `number`
     *
     * Associated interface: {@link PointField}
     */
    Point = "Point",
    /**
     * Value type: `number[]`
     *
     * Associated interface: {@link PointArrayField}
     */
    PointArray = "PointArray",
    /**
     * Value type: `string`
     *
     * Associated interface: {@link FilePathField}
     */
    FilePath = "FilePath",
    /**
     * Value type: `string[]`
     *
     * Associated interface: {@link FilePathField}
     */
    FilePathArray = "FilePathArray",
    /**
     * Value type: `string`
     *
     * Associated interface: {@link EnumField}
     */
    Enum = "Enum",
    /**
     * Value type: `string[]`
     *
     * Associated interface: {@link EnumArrayField}
     */
    EnumArray = "EnumArray"
}
export interface IntField {
    id: string;
    type: FieldType.Int;
    value: number | null;
}
export interface FloatField {
    id: string;
    type: FieldType.Float;
    value: number | null;
}
export interface StringField {
    id: string;
    type: FieldType.String;
    value: string | null;
}
export interface BoolField {
    id: string;
    type: FieldType.Bool;
    value: boolean | null;
}
export interface ColorField {
    id: string;
    type: FieldType.Color;
    value: string | null;
}
export interface PointField {
    id: string;
    type: FieldType.Point;
    value: Point | null;
}
export interface FilePathField {
    id: string;
    type: FieldType.FilePath;
    value: string | null;
}
/** Enum fields contain a reference to the associated {@link Enum} */
export interface EnumField {
    id: string;
    type: FieldType.Enum;
    value: string | null;
    ref: Enum;
}
export interface IntArrayField {
    id: string;
    type: FieldType.IntArray;
    value: number[];
}
export interface FloatArrayField {
    id: string;
    type: FieldType.FloatArray;
    value: number[];
}
export interface StringArrayField {
    id: string;
    type: FieldType.StringArray;
    value: string[];
}
export interface BoolArrayField {
    id: string;
    type: FieldType.BoolArray;
    value: boolean[];
}
export interface ColorArrayField {
    id: string;
    type: FieldType.ColorArray;
    value: string[];
}
export interface PointArrayField {
    id: string;
    type: FieldType.PointArray;
    value: Point[];
}
export interface FilePathArrayField {
    id: string;
    type: FieldType.FilePathArray;
    value: string[];
}
/** Enum fields contain a reference to the associated {@link Enum} */
export interface EnumArrayField {
    id: string;
    type: FieldType.EnumArray;
    value: string[];
    ref: Enum;
}
/**
 * Represents a pre-parsed Entity field
 *
 * Examples:
 *
 * `Array<MyEnum.A>` will result in:
 * ```
 * { type: "Enum", value: "A", ref: MyEnum }
 * ```
 * Where `MyEnum` is not an identifier, but a
 * reference to the Enum:
 * ```
 * const entity = layer.entities[0];
 * entity.fields["enum_field"].ref.uid // you can access the enum properties
 * ```
 *
 * Having all the field interfaces in a union allows narrowing a generic
 * field type down to a specific field type:
 *
 * ```
 * const field: Field = // ...
 * if (field.type === FieldType.Int) {
 *     // value has type `number | null`
 *     const value = field.value;
 * }
 * ```
 */
export declare type Field = IntField | FloatField | StringField | BoolField | ColorField | PointField | FilePathField | EnumField | IntArrayField | FloatArrayField | StringArrayField | BoolArrayField | ColorArrayField | PointArrayField | FilePathArrayField | EnumArrayField;
/**
 * Entities are generic data that can be placed in your levels,
 * such as the Player start position or Items to pick up.
 *
 * Entities are collections of custom fields.
 *
 * Each field has a `type` and `value`.
 *
 * The possible types can be found in {@link FieldType}.
 *
 * Visit https://ldtk.io/docs/general/editor-components/entities/ for more information.
 */
export declare class Entity {
    readonly world: World;
    private data;
    private pxOffset;
    /**
     * Map of entity fields.
     *
     * They can be accessed like regular properties.
     *
     * For a full list of field types, see {@link FieldType}.
     * All possible interfaces are under the {@link Field} union.
     *
     * Usage:
     * ```
     * import { FieldType } from "ldtk";
     *
     * const entity = ... ;
     *
     * for (const field of Object.values(entity.fields)) {
     *     switch (field.type) {
     *         // thanks to the type system, `field` has type `IntField`
     *         // after you check that it's type is `FieldType.Int`.
     *         // value will have the type `number | null`.
     *         case FieldType.Int: UseEntityIntValue(field.value); break;
     *         // same goes for any other field type:
     *         case FieldType.Float: UseEntityFloatValue(field.value); break;
     *         case FieldType.String: UseEntityTextValue(field.value); break;
     *         // enum types have an extra field, `ref`, which holds
     *         // a reference to the parent enum.
     *         case FieldType.Enum: UseEntityEnumValue(field.value, field.ref); break;
     *         // array fields have separate entries in `FieldType`:
     *         case FieldType.IntArray:
     *             // field.value type is `number[]`
     *             UseEntityIntArrayValue(field.value); break;
     *     }
     * }
     * ```
     */
    readonly fields: Readonly<Record<string, Field>>;
    private tileset_;
    constructor(world: World, data: LDtk.EntityInstance, pxOffset: Point);
    /**
     * Grid coordinates
     */
    get gridPos(): Point;
    /** Entity definition identifier */
    get id(): string;
    /**
     * Pivot coordinates (values are from 0 to 1) of the Entity
     */
    get pivot(): Point;
    /**
     * Optional Tile used to display this entity (it could either be the default Entity tile,
     * or some tile provided by a field value, like an Enum).
     */
    get tile(): LDtk.EntityInstanceTile | null;
    /**
     * Optional Tileset used to display this entity
     */
    get tileset(): Tileset | undefined;
    /**
     * Pixel coordinates with all offsets applied
     */
    get pos(): Point;
    /**
     * Pixel coordinates without applied offsets
     */
    get relativePos(): Point;
}
/**
 * Represents a single `Tile` instance.
 */
export interface Tile {
    /**
     * "Flip bits", a 2-bits integer to represent the mirror transformations of the tile.
     * - Bit 0 = X flip
     * - Bit 1 = Y flip
     *
     * Examples:
     * - f == 0 -> no flip
     * - f == 1 -> X flip only
     * - f == 2 -> Y flip only
     * - f == 3 -> both flips
     */
    f: number;
    /**
     * Pixel coordinates of the tile in the **layer**.
     *
     * World position of a tile:
     * ```
     * const layer = ...;
     * for (tile in layer.tiles) {
     *     const tileWorldX = tile.px[0] + layer.pxTotalOffset.x
     *     const tileWorldY = tile.px[1] + layer.pxTotalOffset.y
     * }
     * ```
     */
    px: [x: number, y: number];
    /** Pixel coordinates of the tile in the **tileset** */
    src: [x: number, y: number];
    /** The *Tile ID* in the corresponding tileset. */
    t: number;
}
/**
 * Enum of possible Layer types
 */
export declare const enum LayerType {
    AutoLayer = "AutoLayer",
    Entities = "Entities",
    IntGrid = "IntGrid",
    Tiles = "Tiles"
}
export interface IntGridValueDef {
    /** Color (RGB hex string) */
    color: string;
    /** Unique string identifier */
    id: string | null;
}
/**
 * Layers support different kinds of data, specifically:
 * - [IntGrid](https://ldtk.io/docs/tutorials/intgrid-layers/)
 * - [Tile](https://ldtk.io/docs/tutorials/tile-layers/)
 * - [Entity](https://ldtk.io/docs/general/editor-components/entities/)
 *
 * Visit https://ldtk.io/docs/general/editor-components/layers/ for more information about layers.
 */
export declare class Layer {
    readonly world: World;
    private data;
    private autoLayerTiles_;
    private entities_;
    private gridTiles_;
    private intGrid_;
    private tileset_?;
    /**
     * A map of IntGrid values to IntGrid value definitions.
     *
     * The definition contains the editor color and optional identifier.
     *
     * This is only populated if {@link Layer.type} is `IntGrid`.
     */
    readonly intGridValues: Readonly<Record<number, IntGridValueDef>>;
    constructor(world: World, data: LDtk.LayerInstance);
    /**
     * Grid-based width/height.
     */
    get size(): Size;
    /**
     * Size of a grid cell.
     *
     * Refers to both the width and height.
     */
    get gridSize(): number;
    /** Layer opacity */
    get opacity(): number;
    /**
     * Total layer pixel offset, including both instance and definition offsets.
     */
    get pxTotalOffset(): Point;
    /**
     * Layer type, possible values: `AutoLayer`, `Entities`, `Tiles`, `IntGrid`
     */
    get type(): LayerType;
    /**
     * Non-null if `this.type === "AutoLayer"`
     *
     * {@link Layer.type}
     */
    get autoLayerTiles(): readonly Tile[] | null;
    /**
     * Non-null if `this.type === "Entities"`
     *
     * {@link Layer.type}
     */
    get entities(): readonly Entity[] | null;
    /**
     * Non-null if `this.type === "Tiles"`
     *
     * {@link Layer.type}
     */
    get gridTiles(): readonly Tile[] | null;
    /**
     * This contains the values from the IntGrid, but stored in a 2D array.
     *
     * ```
     * const layer: Layer = new Layer(...);
     * const grid = layer.intGridXY;
     * for (let x = 0; x < grid.length; ++x) {
     *     for (let y = 0; y < grid[x].length; ++y) {
     *         doSomethingWith(grid[x][y]);
     *     }
     * }
     * ```
     *
     * Non-null if `this.type === "IntGrid"`
     *
     * {@link Layer.type}
     */
    get intGrid(): readonly number[][] | null;
    /**
     * Parent Level
     */
    get level(): Level | undefined;
    /**
     * Optional tileset used to render the layer
     */
    get tileset(): Tileset | undefined;
    /** Unique Int identifier */
    get uid(): number;
}
/**
 * Level background data
 */
export declare class Background {
    private data;
    constructor(data: LDtk.Level);
    /**
     * Background color (RGB hex string)
     */
    get color(): string;
    /**
     * Positional information
     * - Cropping
     * - Scale
     * - Top-Left corner
     *
     * {@link LDtk.LevelBackgroundPosition}
     */
    get pos(): LDtk.LevelBackgroundPosition | null;
    /**
     * Background pivot point, values are in the range (0, 1)
     */
    get pivot(): Point;
    /**
     * Background image URL
     */
    get path(): string | null;
}
/**
 * Contains the neighbour's direction relative to this level
 * and a reference to the neighbour.
 */
export interface Neighbour {
    dir: "n" | "s" | "w" | "e";
    level: Level;
}
/**
 * A level is made up of one or more {@link Layer} instances.
 *
 * Each layer holds either bitmap image tiles, entities, or
 * integer values in a grid.
 *
 * Visit https://ldtk.io/docs/general/world/ for more information.
 */
export declare class Level {
    readonly world: World;
    private data;
    readonly background: Background;
    /**
     * An array layer instances.
     *
     * This array is **sorted in display order**: the 1st layer is the top-most and the last is behind.
     */
    readonly layers: ReadonlyArray<Layer>;
    private neighbours_;
    constructor(world: World, data: LDtk.Level);
    /** Unique string identifier */
    get id(): string;
    /** Width/Height of the level in pixels */
    get size(): Size;
    /** Unique Int identifier */
    get uid(): number;
    /**
     * World X/Y coordinates in pixels
     */
    get pos(): Point;
    /**
     * Get neighbouring levels
     *
     * This property is lazily loaded. The first time you access this,
     * it fetches all neighbours and caches them.
     */
    get neighbours(): Neighbour[];
}
/**
 * An Enum value
 */
export interface EnumValue {
    /**
     * Unique string identifier
     */
    id: string;
    /**
     * Pixel x,y coordinates and width/height into the parent {@link Enum.tileset}
     */
    tileSrcRect: {
        x: number;
        y: number;
        width: number;
        height: number;
    };
}
/**
 * Enums are special value types for Entities. ({@link Entity})
 *
 * They could be for example the list of possible Enemy types, or a list of Item identifiers.
 *
 * Each Enum is made up of one or more values. ({@link EnumValue})
 *
 * Visit https://ldtk.io/docs/general/editor-components/enumerations-enums/ for more information.
 */
export declare class Enum {
    readonly world: World;
    private data;
    /**
     * A map of Enum value ids to Enum values.
     */
    readonly valueMap: Readonly<Record<string, EnumValue>>;
    /**
     * Array of this Enum's value ids
     */
    readonly valueIds: string[];
    /**
     * Array of this Enum's values
     */
    readonly values: EnumValue[];
    /**
     * Optional icon tileset
     */
    readonly tileset: Tileset | null;
    constructor(world: World, data: LDtk.EnumDefinition);
    /** Unique string identifier */
    get id(): string;
    /** Unique Int identifier */
    get uid(): number;
}
/**
 * Tilesets are bitmap images which are used to render Tile layers.
 *
 * See {@link Layer} for more information.
 *
 * Visit https://ldtk.io/docs/tutorials/tile-layers/ for more information about tileset usage.
 */
export declare class Tileset {
    readonly world: World;
    private data;
    constructor(world: World, data: LDtk.TilesetDefinition);
    /** Unique string identifier */
    get id(): string;
    /** Distance in pixels from image borders */
    get padding(): number;
    /** Image width/height in pixels */
    get size(): Size;
    /** Path to the source file, relative to the current project JSON file */
    get path(): string;
    /** Space in pixels between all tiles */
    get spacing(): number;
    /**
     * Size of one tile
     *
     * This represents both width and height
     */
    get gridSize(): number;
    /** Unique Intidentifier */
    get uid(): number;
}
/**
 * Worlds contains various definitions ({@link Enum}, {@link Tileset}) and
 * are made up of one or more {@link Level}s, which utilise these definitions.
 *
 * Worlds can have different layouts: `Linear`, `Free`, or `GridVania`.
 *
 * Linear worlds are organized as a linear sequence of levels, either
 * horizontal or vertical.
 *
 * Free worlds are not organized, all levels appear freely in 2D space.
 *
 * GridVania worlds are organized into a uniform 2D grid, where each level
 * can take up one or more grid cells.
 *
 * Visit https://ldtk.io/docs/general/world/ for more information.
 */
export declare class World {
    private data;
    /**
     * A map of Level ids to Levels.
     */
    readonly levelMap: Readonly<Record<string, Level>>;
    /**
     * Array Levels Ids defined for this World.
     */
    readonly levelIds: string[];
    /**
     * Array Levels defined for this World.
     */
    readonly levels: Level[];
    /**
     * A map of Tileset ids to Tilesets.
     */
    readonly tilesetMap: Readonly<Record<string, Tileset>>;
    /**
     * Array Tilesets Ids defined for this World.
     */
    readonly tilesetIds: string[];
    /**
     * Array Tilesets defined for this World.
     */
    readonly tilesets: Tileset[];
    /**
     * A map of Enum ids to Enums.
     */
    readonly enumMap: Readonly<Record<string, Enum>>;
    /**
     * Array Enum names defined for this World.
     */
    readonly enumIds: string[];
    /**
     * Array Enums defined for this World.
     */
    readonly enums: Enum[];
    private constructor();
    /**
     * Find a level for which a given `predicate` is true.
     */
    findLevel(predicate: (l: Level) => boolean): Level | undefined;
    /**
     * Find a tileset for which a given `predicate` is true.
     */
    findTileset(predicate: (t: Tileset) => boolean): Tileset | undefined;
    /**
     * Find an enum for which a given `predicate` is true.
     */
    findEnum(predicate: (e: Enum) => boolean): Enum | undefined;
    /**
     * Find a level by its `uid`.
     */
    findLevelByUid(uid: number): Level | undefined;
    /**
     * Find a tileset by its `uid`.
     */
    findTilesetByUid(uid: number): Tileset | undefined;
    /**
     * Find a tileset by its `path`.
     */
    findTilesetByPath(path: string): Tileset | undefined;
    /**
     * Find an enum by its `uid`.
     */
    findEnumByUid(uid: number): Enum | undefined;
    /**
     * True if this world was saved with `separate level files` option.
     */
    get externalLevels(): boolean;
    /**
     * Background color (RGB hex string)
     */
    get bgColor(): string;
    /**
     * The world layout
     *
     * Possible values: "Free", "GridVania", "LinearHorizontal", "LinearVertical"
     */
    get layout(): LDtk.WorldLayout;
    /**
     * Load and parse all external levels and enums.
     *
     * If a level is already loaded, it won't be loaded again.
     */
    loadLevels(): Promise<void>;
    /**
     * Load and parse external level `identifier`.
     *
     * This allows for dynamically loading individual levels.
     *
     * If a level is already loaded, it won't be loaded again.
     */
    loadLevel(identifier: string): Promise<void>;
    /**
     * Parse an existing JSON object as an LDtk project file
     */
    static fromJSON(data: LDtk.World): World;
    /**
     * Asynchronously load and parse an LDtk project file
     */
    static fromURL(path: string): Promise<World>;
    /**
     * Used for fetching external levels
     */
    private fetchLevel;
    /**
     * Load the raw JSON without any utilities.
     *
     * This does the following in Node:
     * ```
     * const path = ... ;
     * import * as fs from "fs";
     * const world = await new Promise((resolve, reject) => {
     *     fs.readFile(path, { encoding: "utf-8" }, (err, data) => {
     *          if (err) reject(err);
     *          else resolve(JSON.parse(data) as LDtk.World);
     *     });
     * })
     * ```
     * And in the browser:
     * ```
     * const path = ... ;
     * const world = await (await fetch(path)).json() as LDtk.World;
     * ```
     */
    static loadRaw(path: string): Promise<LDtk.World>;
}
